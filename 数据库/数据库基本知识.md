<!-- TOC -->
- [基本认识](#基本认识)
	- [使用数据库的前期准备](#使用数据库的前期准备)
	- [用户的创建](#用户的创建)
	- [函数](#函数)
	- [集合](#集合)
- [初识SQL](#初识SQL)
	- [SQL的动词](#SQL的动词)
	- [数据定义](#数据定义)
- [基本表的SQL操作](#基本表的SQL操作)
	- [数据定义](#数据定义)
	- [数据查询](#数据查询)
	- [数据更新](#数据更新)
	- [空值](#空值)
	- [额外](#额外)
- [SQL进阶操作](#SQL进阶操作)
- [进阶](#进阶)
	- [范式](#范式)

## 基础认识

### 使用数据库的前期准备

1. 使用Oracle,需要打开两个服务（以Oracle 11g Express edition为例）,具体操作如下：
	- Windows操作系统中，使用快捷键Win+Q打开搜索栏，搜索“服务”
	- 在服务中找到以下两个服务后，右键启动
		- OracleXETNSListener
		- OracleServiceXE  
	
	**两个服务的作用：**

	OracleXETNSListener作用：Oracle监听器，监听用户的请求等等（如果有客户连接到数据库，这个功能必须得打开）【当被监听的对象发生变化时（某种请求），监听器的某个方法将会被立即执行】。  
	OracleServiceXE作用：数据库得主服务器，此服务启动才能启动Oracle。  

![](数据库图片/服务.png)

2. Oracle的第一行代码（以图形界面软件Oracle SQL developer为例）     
	- 新建sys管理员数据库连接  
	
![](数据库图片/Oracle SQL developer 连接.png)

	- 备注：如果你要创建新的用户，必须得通过sys系统管理员/system本地管理员才能新建其他用户，因为Oracle默认只有sys系统管理员/system本地管理员/Scott普通用户（默认不解锁） 

	**防止掉坑：**

	名词解释-端口  
		- 1-49151端口：依据互联网传输层TCP/IP协议的协议通信，不同的协议都对应不同的端口  
		- 1521 对应Oracle数据库default listener  
		
	在命令行界面（cmd）使用sqlplus遇到的问题  
		- Oracle乱码：客户端服务端的字符集设置不一样：  
		1、常用unicode字符集 set NLS_LANG=american_america.AL32UTF8 可以通过修改注册表键值永久设置 HKEY_LOCAL_MACHINE\SOFTWARE\ORACLE\HOMExx\NLS_LANG  
		2、常用中文字符集（一般不用） set NLS_LANG=SIMPLIFIED CHINESE_CHINA.ZHS16GBK   
  		3、需要注意的点：环境变量  

	注册表
		- 以后快速找到某个注册表：将注册表添加到收藏夹
		- 找注册表的值：模糊搜索：“HKEY_LOCAL_MACHINE\SOFTWARE\ORACLE\”（适时可以加‘/’）

### 用户的创建

```mysql
/* 数据库的操作（Oracle的注释有两种/*和--和） */
--一开始的用户只有管理员:sys超级管理员，system本地管理员,（scott普通用户，默认不解锁）通过这两个管理员可以创建其他用户
--创建myDataBase用户;identified by后面是用户密码;
--刚创建的用户是没有任何权限，通过grant/revoke授予/收回用户的权限
--resource访问权限，访问表等；connect连接数据库;dba所有的权限;
create user myDataBase identified by uber;
grant resource,connect,unlimited tablespace,create view to myDataBase;

--dual表是实际存在的虚表，由sys创建，任何用户都可以读取
--可以通过该dual表查看"系统时间"，"显示当前用户"（和show user的作用一样）
select sysdate from dual;
select user from dual;
show user;

--查看所有的用户(只能sys/system管理员模式下查看)
select username from dba_users;

--提交/回滚
commit;
rollback;

--删除用户
drop user mydatabase;

```

### 函数

```mysql
-- trim / ltrim / rtrim（修剪）：删除左右空白字符串
-- 输出名称是以“DB_”开头，倒数第三个字符是i
select * from course where trim(cname) like 'DB\_%i__'escape '\';

--转义字符 escape'\'(斜线后面的不会被理解为通配符)
select * from course where trim(cname) like 'DB\_%i__'escape '\';

--any(全部中取“一个”)/all（“全部”）
select sname,sage from student where sage<any(select sage from student where sdept='CS')and sdept<>'CS';
select sname,sage from student where sage<all(select sage from student where sdept='CS')and sdept<>'CS';
```

### 集合

```mysql
-- 自己理解：只能对于同一个表（值域要想等），但是又可以通过and or 来实现，所以集合没什么用
-- union：并集
-- intersect：交集
-- minus：差集
select * from sc where cno='1'
union 
select * from sc where cno='2';
```
### 表的操作

```mysql

```

### 数据操作

```mysql

```

### 字符集编码

```mysql

```

### 数据类型（列类型）

```mysql

```

### 列属性(列约束)

```mysql

```

### 建表规范

```mysql

```

## 初识SQL

### SQL的动词

|SQL功能		|动词								|
|:---------:|:-----------------:				|
|数据定义	|**C**reate,**D**rop,**A**lter		|
|数据操纵	|Insert,Update,Delete				|
|数据查询	|Select								|
|数据控制	|Grant，Revoke						|

### 数据定义

|操作对象	|创建				|删除				|修改				|
|:---------:|:-----------------:|:-----------------:|:-----------------:|
|模式		|Create Schema		|Drop Schema		|---				|
|索引		|Create Index		|Drop Index			|Alter Index		|
|视图		|Create View		|Drop View			|---				|
|表			|Create Table		|Drop Table			|Alter Table		|

Oracle中一个模式对应一个表，因此不用特意的去操作（增删改）Schema

## 基本表的SQL操作

### 数据定义

**定义基本表**

联想具体记忆：表头的**名字**+表头的**类型**+**身份**【写代码的时候就像说话一样】

```mysql
-- 建立一个Student表
Create table student
(sno char(9) primary key,
sname char(20) unique,
ssex char(2),
sage smallint,
sdept char(20)
);

--建立一个Course表
Create table Course
(cno char(4) primary key,
cname char(40)not null,
cpno char(4),
ccredit smallint,
foreign key(cpno) references course(cno)
);

--建立学生选课表SC
Create table SC
(sno char(9),
cno char(4),
grade smallint,
primary key(sno,cno),
foreign key(sno)references course(cno),
foreign key(cno)references student(sno)
);

```

**修改基本表**

Alter table 表名 [Add/Drop column/Modify····]

```mysql
--增加一列
--删除一列
--修改类型
--增加约束条件
alter table student add S_entrance date;
alter table student drop column s_entrance;
alter table student modify sage varchar2(40);
alter table student add unique(Sname);
```

**删除基本表**

cascade：级联删除，相关的信息都被删除
restrict:删除被限制，若是被其他表的约束所引用（check，foreign）、表上有视图等则删除不了

```
drop table student cascade;
```

**视图的增删**

create view <视图名> [<列名>]
as <子查询> [with check option];

with check option:通过视图更新table时，更新的数据必须满足“where后面的内容”?

> view可以理解为table的外衣，故用as且没有alter;index理解为在table上，故用on且可以alter。

```mysql
create view st as select sno,sname from student;
create view sc_copy as (select sno,grade from student,sc where student.sno=sc.sno and sno.name="张三")with check option;  

drop view sc_copy;
```

**索引的增删**

create [unique][cluster] index <索引名> on <表名>[<列名>]

> Oracle中cluster不能在单个表上建立cluster索引

```mysql
create index sname_idx on student(sname);
create unique index sno_idx on student(sno); 

drop index snm_idx;
```

### 数据查询

select [all|distinct] <目标列表达式>
from <表或视图名>| （select 语句）[AS]<别名>
where <条件表达式>
group by <列名> [having <条件表达式>]
order by <列名>[ASC|DESC]

> order by 默认升序

```mysql

1、select

	-- 可以使用*表示所有字段
	-- 可以使用表达式（计算公式、函数调用、字段也是个表达式）
	-- 可以为每个列使用别名。适用于简化列标志，避免多个列标识重复(出生年龄的引号可加可不加)
	-- 名字拓展(注意是单引号' '||)
	-- distinct 只输出不同值
	select * from sudent;
	select sname NAME,'year of birthday:'BIRTH,2019-sage BIRTHDAY,lower(sdept) DEPARTMENT from student;
	select 2019-sage 出生年龄 from student;
	select '年龄:'||sage from student;
	select distinct sno from sc;

2、from (**对表的连接，配合where/in**)  

	-- 等值连接
	-- 自身连接
	-- 外连接
	-- 多表连接
	-- 嵌套查询：In Exist

（当涉及多个表时，以student，sc,course 总表的角度思考问题，一般使用自然连接（如果条件是sno/cno等相同值时），如果条件是需要比较的话，则一般采用“一般的连接”）  
 (使用in的优势：在select的内容只存在一张表中时，你使用in会更容易理解)  
（where拓展:左外连接（左边表的所有元组都会显示出来，右边表如果没有值则设置为null），自然连接（默认相等连接，省去where后面的student.sno=sc.sno），一般的连接（通过where判断相等））

	/* 表连接的两种常用的方式 */
	/* 自己的理解：使用笛卡尔积时，where后面必须跟笛卡尔积以什么的条件筛选（一般：student.sn0=sc.sno,可以将三个表连接起来，但是这样子使用select的时候，有重复列的sno,cno需要上student.sno ，没有重复列的sname则不用 ；） */
	/* 自己的理解：通常有三个表，学生表和课程表是基础表，还有一个类似函数的表（选修表）*/
	 
	--输出和刘晨同个系的所有学生的姓名
	--in
	select * from student where sdept in(select sdept from student where sname='刘晨');  
	--笛卡尔积
	select s2.* from student s1,student s2 where s1.sname='刘晨'and s1.sdept =s2.sdept;
	--输出选修了“信息系统”这门课所有学生的学号和姓名
	--in
	select student.cno,sname from student where sno in
	(selcet sno from sc where cno in (select cno from course where cname='信息系统') );
	--笛卡尔积
	select student.sno,sname from student,sc,course where sno from student.sno=sc.sno and sc.cno=course.con and cname='信息系统';
	--输出课程号，关于这门课的成绩大于该学生的平均成绩（注意，这里内表必须：sc2.sno=sc1.sno）
	select cno from sc sc1 where grade>(select avg(grade)from sc sc2 where sc2.sno=sc1.sno);
	
	/* 左外连接，自然连接 */
	--左外连接（会有null）
	select  stuent.sno.cno.grade from student left outer join sc on student.sno=sc.sco (不会去掉共同列的stuent.sno=sc.no)
	select * from student left outer join sc using (sno) 【因为会自动去掉sno，所以可以直接用*】
	--自然连接
	select * from student natual join sc; 会去掉相同的列
	-- 自然左外连接
	from student natual  left outer join sc

3、where（删选元组）
	
	--逻辑运算：与或非
	and  
	or  
	not:not(grade is null)  ||  grade is not null(取反：对于一些要求，比如"全部"很有关键性作用)
	
	--算术范围匹配
	> < = <>(不等于) between and /not between and
	 
	-- 单个字符串匹配：like 如果like后面不含通配符，则like等于=；not like等于!=/<>;如果你要查找包含'%''_'
	(模糊查找：%匹配任意个字符(长度可以为0)；_匹配一个字符)（Oracle中一个汉字字符占2~3个字节）
	
	--多个字符串内容匹配：in
	in：字符串匹配：not in（'IS','MA','CS'）
	
	--null(null是随机数，所以两个null值不相等)
	判断是否为null:is null

	select sname,sdept,sage from student where sage not between 20 and 30;
	select sname,ssex from student where sdept in('CS','MA','IS');
	select sname from student where sname like '张%';
	select cno,ccredit from course where cname like 'DB\_Design' escape '\';

4、group by (对元组数据进行“分组/合并”操作)（但再也不能select *，因为不能输出有争议的值，一般用于sum,avg等聚合函数）
	count：计算数目 （遇到空值跳过）
	sum：求和
	min：最小值
	max：最大值
	avg：平均值

5、聚合函数（没有group by也可以使用，没使用group by相当于表中只有一组）
	count：计算数目 （遇到空值跳过）
	sum：求和
	min：最小值
	max：最大值
	avg：平均值

5、having
	对group by 进行筛选

6、order by
	asc(asc)：升序（默认）
	disc(discending)：降序
```

### 数据更新

数据更新的操作有三种：增加元组、修改元组、删除元组

**增加元组**

insert into <表名>[<属性列>]
values(<常量1>)  

可以增加一条元组，也可以插入子查询的结果

需要注意的地方：
1. 若是insert中没有插入对应的属性值，则默认为NULL，但是，定义这些表时，该列如果为not null，则会出错
2. 字符串参数要用单引号（英文符号）括起来

**修改数据**

update <表名> set <列名>=<表达式> [where <条件>]

可以修改一条元组，可以用子查询修改多个元组

**删除数据**

delete from <表名> [where <条件>]

删除的是表的元组，而不是表的定义（表的定义仍在字典中）

```mysql
-- 插入一条数据
-- 插入子查询结果

insert into student(sno,sname,ssex,sdept,sage)values ('201215128','陈冬','男','IS',18);

create table dept_age(
sdept char(15),
avg_age smallint
);
insert into dept_age select sdept,avg_age from

-- 修改年龄
-- 将所有学生的年龄增加一岁
-- 

update student set sage=22 where sno='201215121';
update studnet set sage=sage+1;
update sc set grade=0 where sno in(select sno from student where sdept='CS');

-- 删除某一个元组的值
-- 删除多个元组的值
-- 带子查询的删除语句

delete from student where sno='201215121';
delete from sc;
delete from sc where sno in(select sno from student where sdept='CS');

```

### 空值

定义：
- 空值是“不确定”/“不存在”/“无意义”的值

空值的约束条件：
- 创建表时如果定义约束条件为not null，则这个值不能为空

空值的运算：
- true false unknow 构成三元运算

```mysql
-- 空值的判断
-- 选出1号课程 不及格的学生以及缺考的学生

select * from student where sname is NULL or ssex is NULL or sdept is NULL;
select * from sc where cno='1' and (grade<60 or grade is null); 

```

### 额外

```mysql
	-- 查询当前用户下的所有表
	1. dba_tables(在dba权限下可查看)
	2. all_tables(在dba权限下可查看)
	3. user_tables(当前用户下可查看)
	
	select * from user_tables;
```

## SQL进阶操作

### 视图

定义：
1. 视图是从一个或几个基本表（或视图）到处的虚表
2. 视图不存放数据，只存放视图的定义
3. 视图可以进行*视图的*删除，更新（*元组的*增、删、改，但是会受限制），查 

精髓：
1. *视图就是对表的一定程度的选取*
2. 在执行create view语句时，只是把视图的定义存入数据字典，并不执行select语句

作用：
1. 视图能够简化用户的操作（将select的结果转化为view）
2. 视图使用户能从多种较多看待用一数据
3. 视图对重构数据库提供了一定程度的逻辑独立性
4. 视图能够对机密数据提供安全保护
5. 适当利用视图可以更清晰地表达查询

**创建视图:**

create view <视图名> [<列名>] as <子查询> [with check option]
1. with check option:对试图的*元组的*的增删改时，需要满足where后面的条件
2. 视图的列明要么全部省略 要么全部指定，没有第三种选择

**删除视图**

drop view <视图> [cascade]

**查询视图**


```mysql

-- 

```

## 进阶

### 范式

**何为范式：**  一种依靠本身成功示范的工具。【范式是标准的，但不一定是最合适的。
不一定所有的情况下都要使用范式，根据情况决定】

**范式为了解决什么问题：**
```
假设数据库的元素都在同一个表中，则会有以下问题（以学生表数据为例）  
	- 数据冗余
	- 插入异常：要插入没有学生的系，因为sno为主码，因此插入不了
	- 删除异常：删除某个系所有的学生，但是该系的信息也会全部不见
	- 更新异常：更新系主任，所有的学生都要更正一遍
```

**名词解释：**
```
	- 完全函数依赖：全部的主属性结合起来->全部的非主属性
	- 部分函数依赖：全部的主属性的子集->部分非主属性
	- 传递函数依赖：A->B A->C 但是B->C; 存在的问题：删除会全部删除
	- 多值依赖：
```

**为什么会导致这些问题：**
```
	- 非主属性对码（候选码）的部分函数依赖：
	- 非主属性对码的传递函数依赖
	- 主属性对码的部分和传递函数依赖
	- 平方且非函数依赖的多值依赖
```

**范式：**
```
通过不断的分解关系模式，得到更高一级范式的关系模式
	- 1NF：数据库的原子性
	- 2NF：消除部分函数依赖
		  【判断是不是2NF：非主属性 只能通过 所有的主属性推出】
	- 3NF：消除传递依赖
		  【增加没有学生的一个系，删除该系的所有学生，但是系得信息不会得到保留，修改系得主任过于麻烦】
	- BCNF：消除主属性的部分和传递依赖
	- 4NF：消除非平方且非函数依赖的多值依赖
```




