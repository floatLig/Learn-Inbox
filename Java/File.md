## 应用

这些知识点：框架会给我们简化了

上传下载就是I/O

文件就是存储数据的地方

以程序为中心，进入程序就是输入流，从程序输出就是输出流
在服务器和客户端之间：服务器就是中心

CommonsIO

后期我们关注的是：客户的需求；更多的是关注的是需求，不是关注技术，关注技术是架构师

File  

方向分：输入输出

InputStream：字节，计算机看懂

OutStream

Reader：字符输入流，人类看到

Writer：

操作系统：Closeable  Java通知系统可以释放资源了；关闭流接口

Flushable : 强制刷新；刷新流接口；立马可见

Serializable；序列化结构  存储对象

5个类，3个接口

！！！！文件的拷贝

看看说明说，API，用到了就去找

功能分

结点流：可以直接从？？
所有的操作都基于结点流

处理流、包装流：装饰设计模式；提高性能的

字符集就是一个大字典

字节流和字符流：底层还是字节流操作，自动搜寻了指定的码表

从字节的角度

掌握重点

！！！！！！多敲几遍

### File:

表示：文件、文件夹；代表的是一种抽象的表示形式，是Java虚拟机和操作系统的桥梁

如何看懂API，私有属性不显示不来

有构造器：直接new
没有构造器：工具类，静态方法

**这个老师打的代码，就是源码，或许他没说而已**

### 文件编码

编码encode：字符到字节   英文到二进制
解码decode：字节到字符

字符集：Java字符集使用16位双字节，因此可以用中文
码表

US-ASCII：英文字符
ISO-8858-1 / GBK（汉字内码扩展规范）：中文字符

Unicode:
- UTF-8 变长的Unicode 变长Unicode（1-3个字节）英文1个，中文3个，国际通用
- UTF-16BE：定长Unicode字符（2个字节） 大端表示 big
- UTF-16LE：定长Unicode字符（2个字节） 小端表示 little

### 递归的精华

表示这个递归的属性，比如这个递归属于第几层：多添加一个**参数n**

递归：自己调用自己；  遇到什么情况下停下来；不停下来，下一个参数要怎么写

统计在递归中的属性的总计：在**递归函数外**用一个变量统计,联想自己做过的数据结构的实验“大数据”，统计文件夹的个数，我在外头用了一个sum的变量统计

乱码的原因：
- 字符不统一
- 字节数缺少

！！！！核心代码打10遍，你就会在这个反面打通任督二脉

字节数组：电脑内存、服务器内存；
字节数组可以不用关闭，因为内存直接由垃圾回收机制释放
任何东西都可以转为直接数组
内存的东西不易太多
ByreArrayInputList

## 设计模式

面向对象的大Boss

现在的面向对象都是虾兵蟹将

GOF设计模式：解决复杂系统的设计模式，一种套路、一种攻略；固定的

工厂、装饰

高内聚、低耦合

### 装饰器设计模式

 要用新增的方法，不要用多态！因为多态性能提升不高
要用新增的东西

转化流
是字节流与字符流之间的桥梁，能够将字节流转化为字符流
1、方便处理，给的流都是纯文本
2、可以指定字符集

接口也可以new实例，然后向上转型： 参数(Closeable...ios)  可传入（InputStream is）

commonsIO

框架：必须按照他的思想来做

FileUtils

## 线程

服务器：网站同时访问
三高：高可用、高性能、高并发 （中高级架构师）

JUC并发编程，高级并发编程

process线程：不同的执行路径
thread进程

main 主线程

多用Runnable接口

用户线程
守护线程：保护用户 、

start 和 run 方法

Java本地接口 run0 我们看不到

同runable对比：call可以throws，可以返回值

### 代理：

记录日志、增强服务

静态代理：肯定会用作日志用的

动态代理：

## lambda

避免匿名内部类过多
实质是函数式编程
 
简单的线程用lambda写

## 线程状态

新生状态：创建，Thread t = new Thread（）

就绪状态：
- start（）
- 阻塞事件解除
- yield
- jvm

运行状态：调度,run()

阻塞状态:
- sleep
- yield：礼让 
- wait
- join 插队
- read / write

死亡状态
- stop()
- 让这个代码执行完，想法设法让代码执行完

以面向对象角度思考

 
只代表概率

daemon 守护线程
线程分为守护线程和用户线程
JVM 等待用户线程执行完毕，而不用等待守护线程执行完毕
默认用户线程

原麦山丘  借助互联网的思维

线程同步、并发控制
synchronized  --->  线程安全；但是会出现性能问题

- 做法synchronized方法 和 synchronized块，多用synchronized块
- 目标要对、效率要高
- synchronized锁的对象必须是不变的对象，但是对象里面的属性可以改变；例如锁的是：银行账号；里面的属性钱可以变化；
- double checking ：双重检查

同一个对象被多个对象同时操作

同步块：同步监视器

避免死锁的发生：不要在 同一个同步代码块 中，拥有太多锁；多个锁分成多个同步代码块

### 有感而发

后期的代码都是在简单的代码上堆积起来的

- 基础代码
- 容器: 善于利用容器的RemoveAll（）等方法
- synchronized 控制并发


23种设计模式

生产者消费者模式：线程的模式；使用消息队列；解决通信问题
生产者：负责生产数据的模块
消费者：负责处理数据的模块
解耦：提高效率；
管存法：  Buffer 共享内存
- 生产者：多线程
- Buffer：共享内存；队列；通信： 
- 消费者：多线程
信号灯法：
服务器

PV page view:
UV user view/unique view:
VV visted view:

应用层
服务层
数据层

任务定时调度

框架Quartz
Scheduler 调度器，控制所有的调度
Trigger 触发条件，采用DSL模式
JobDetail 需要处理的Job
Job 执行逻辑

### 导入框架

- 复制粘贴lib的文件
- 右键--Build Path
- 新的框架：API 使用文档 手册 参考写好的实例 

HappenBefore:指令重排，会遵守数据的依赖性，联想可串行化调度？像幽灵一样可怕？？

volatile:保证线程间变量的可见性，简单地说就是当线程A 对变量X进行修改后，（cache修改后，立马写回主存），但是现在不多见了，因为现在电脑地性能不错

设计模式：单例模式
任务管理器

ThreadLocal

锁：
可重入锁：如果某一个线程试图获取一个已经由它自己持有的锁时，那么这个请求会立刻成功，并且会将这个锁的计数值+1，而当线程退出同步代码块时，计数器会逐层递减；
如果不这么做，就立刻会发生死锁

CAS：
悲观锁：独占锁，synchronized
乐观锁：Compare and Swap 比较并交换

- 多线程：多条路
- 线程实现：runnable;thread;call
- new Thread(new MyThread()).start();代理
- 新生装填--就绪状态--运行状态--死亡状态  （阻塞状态）
- 停止一个线程：用一个标志，外界更改这个标志
- 阻塞：sleep（模拟网络延迟）；join(插队)；yield(高风亮节)；
- currentThread.getName();
- 优先级：代表概率
- 守护线程，用户线程

- 并发：保证多线程环境下对同一份资源的访问（写）
- 同步：synchronizate 同步块：找对象 + 找合适的范围 + double checking 
- 指令不重排：v
- CAS
- 生产者消费者：wait + notify  信号灯法 + 管存法
- JUC 高级并发
- 应用起来简单，底层还是挺复杂的