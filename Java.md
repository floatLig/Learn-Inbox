# Java
### Java初级
- [成员变量](#成员变量)
- [函数](#函数)
- [面向对象](#面向对象)
- [继承、封装、多态](#继承、封装、多态)
- [思考经验](#思考经验)

![](https://github.com/floatLig/Learn-Inbox/blob/master/media/%E6%80%9D%E7%BB%B4%E8%AE%B0%E5%BF%86%E7%BB%93%E6%9E%84%20(2).png)

## 成员变量 

###  注释
- 单行注释
- 多行注释：
- 文档注释：文档注释会**自动生成API**，因此开发项目最好使用文档注释
```java
	//单行注释
	
	/*
	 * 多行注释
	 */
	
	/* 多行注释的另一种用法，可用于代码中间解释，但不推荐*/
	
	/**
	 * 文档注释
	 * 文档注释：比多行注释多写了一个*
	 */
```

### public static final *double* MAX_MARK =(1.0+90L)之double	
- 用于常量：必须赋初值，赋初值后不能再修改:PI
- 用于方法：不能被重写
- 用于类：不能被继承：String	

### public static final *double* MAX_MARK =(1.0+90L)之double
- 基本数据类型
	- boolean是1byte
	- char可以用作数字处理：'a'+4=101
	- 使用long时：123L而不是123l(很容易混淆)
	- 不要long a=b+c而要long a=(long)b+c
		- （long）b会自动将右边的等级提成为long，这样就不要报错
	 
### public static final double *MAX_MARK* =(1.0+90L)之MAX_MARK
- 标识符命名规范
	- 驼峰原则：studentAge
	- class类名：首字母大写
	- 成员变量、函数：首字母小写
	- final常量：全部大写，用下划线连接
- 变量
	- 一行申明一种变量就可以，不要多写

```java
	int age;  
	int grade;
```

	- 静态变量static
		- 从属于**类**
	- 成员变量
		- 会有默认初始值，故可以不用初始化
		- 从属于**对象**
	- 局部变量
		- 从属于**方法**
	- 这些变量在初始化时，**最好都赋初始值**

### public static final double MAX_MARK *=* (1.0+90L)之=
- 自动类型转化
	- 容量小的数据类型向容量大的数据类型转化:int->long->float->double
	- 1e2=100
	- 整数默认是int类型，小数默认是double类型
	- 强制类型转化
```java
	long a=1;//这里的1是int,int自动转化为long
	float b=1.0F;//这里的1.0是double，double不能自动转化为float，所以必须写成1.0F
```
	- 因为浮点数（float、double）是自动类型转化，因此不精确。若是要精确的比较使用**BigDecimal函数**

### public static final double MAX_MARK = (1.0*+*90L)之+
- 运算符
	- %取余
```java
		int a=-7%-2;//-7影响结果为“-”;-2对结果的正负不影响
		System.out.println(a);//-1：
```
	- 运算符会自动转化类型
- 逻辑运算符
	- &&短路与--&与
```java
		boolean a= (1>2)&&(1/0>1);//不会报错“除数为0”，因为遇到前面是false，短路与&&不会继续往后看，写代码时推荐使用这个
		boolean b= (1>2)&(1/0>1);//会报错，因&无论前面是true还是false,都会继续往后读
```
- 位运算符
	- & | ^ ~
	- <<2:左移两位即“乘2”
	- +字符串连接符：1+“2”=12

	
### 对象
- Scanner
	- Scanner sc=new Scanner(System.in)

-----

## 函数
- 流程控制语句
	- 顺序
	- 选择(i)
		- if else
		- switch(case不用加{})
	- 循环
		- for
		- while
		- break、continue终止的是循环，而不是if【若要跳出多层循环，使用return跳出函数】
		- continue,break配合if在循环中使用
	- 任何算法都是建立在顺序、选择、循环之上的
	- 多个for，最外层的for是最大框架
- public static void main(String[] args)
	- return
		- 返回类型
		- 终止函数
- 常用
	- 函数被static修饰（属于类），可直接调用，不用创建该类的对象（public不行，因为public的功能不是这个）

-----

## 面向对象

### 生活皆对象
- 编程思想（逐渐进步）
	- 面向过程思想
		- 一步一步怎么做
		- 适合简单，不需要协作的事务
	- 数组
		- 数据也是对象
	- 面向对象
		- 宏观上用面向对象把握，微观仍是面向过程->函数
		- 都是解决问题的思维方式，都是代码组织的方式
		- 量变引起质变
- 生活中的对象
	- 公式项目制
		- 微信项目组--包括财务，可以说是独立公司
		- 麻雀虽小五脏俱全

### JVM的内存分析

![](https://github.com/floatLig/Learn-Inbox/blob/master/media/%E5%A0%86%E3%80%81%E6%A0%88%E3%80%81%E6%96%B9%E6%B3%95%E5%8C%BA.png)

- 栈stack--**DO**
	- 描述的是**方法**执行的内存模型
		- 主函数main运行
		- 构造函数（运行后立马被销毁）
	- 类似于子弹夹
		- 栈帧
		- 线程私有：不能共享
		- 先进后出，后进先出：main是最先创建的，最后销毁
		- 速度快
- 堆heap--**实例-大千世界**
	- 存放创建好的对象和数组（数组也是对象）
	- 所有线程共享
	- 不连续的内存空间，分配灵活、速度慢
- 方法区method area--**蓝图、基础数据**
	- JVM只有一个方法区，被所有线程共享
	- 方法区实际上也是堆，用于储存**类，常量的相关信息**--静态的一些数据
		- 代码
		- 静态变量
		- 静态方法
		- 字符串常量
- 合起来
	- **栈**（ToDo）调用**堆的对象**，**堆的对象**的内容由**其他堆、方法区**的内容组成

### 垃圾回收机制Garbage Collection

![](https://github.com/floatLig/Learn-Inbox/blob/master/media/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6.png)

- 针对对象（**堆**），类似回收垃圾的服务员
	- C++没有垃圾回收机制，使用后必须把残渣带走，如果没有带走，则这块内存不能使用
- 算法：根搜索算法（引用可达法）
- 原理
	- 发现无用的对象
	- 回收无用对象占用的空间
	- Minor GC/Major GC/Full GC(全部清理，代价较高)
	- 年轻代
		- Eden：对象刚创建出来
		- Survival1
		- survival2
	- 年老代
		- Tenured/Old
	- System.gc()
		- 向系统建议调用垃圾回收机制
		
### 编程中的对象实现
- JVM顺序
	- 方法区：
		- 父类静态变量->父类静态代码块
		- 子类静态变量->子类静态代码块
	- 栈
		- main函数
	- 堆
		- 父类变量--父类代码块（对该类的共同属性进行赋值）--父类构造器
		- 子类变量--子类代码块（对该类的共同属性进行赋值）--子类代码块
- 类（蓝图）（抽象-抽出像的东西）
	- 书写注意：类是没有参数的
	- 属性（调用对象的属性“.”）
	- **类中有类**
	- 成员方法（调用对象的方法“.”）
- 对象object / instance（实例）
	- 和对象的关系
		- 是对象的模板
	- 使用：用new调用构造方法->初始化/实例化
		- 无参的构造方法由系统自动创建
		- 方法名称和类名保持一致
		- 经常重载（不用实例化）
		- this:表示创建的**这个对象**
		- 构造方法的第一句都是super（）--系统默认添加
	- 创建对象时的底层操作
		- 在堆中分配对象空间，并将对象成员初始化为0或null
		- 执行属性值的显式初始化（实例化+代码块）
		- 执行构造函数（实例化）
		- 返回对象地址给相关的变量
	- this
		- 表示创建的这个对象
		- 不能用于static，因为static位于方法区，而this只能调用**堆**里面对象的东西
- 数组（arrays）也是对象
	-	数组也是对象：相同类型元素，有下标
	- 数组的每个元素都可以看成是：成员变量
	- 使用--声明：
		- User[] arr
		- 默认值和成员变量一样：0/false/null
		- 指明长度/分配**数组空间**（记录地址）：arr1=new User[10]
		- 分配**对象空间**：arr[0]=new arr()
		- 赋值
	- 使用--初始化
		- 静态初始化(直接赋值：数组空间确定、数组指定对象内容也确定)：
```java
		int arr[]=new{1,2}；//数组可以存放int类型
 
		User[] b={
		new User(1,"zzl"),
		new User(2,"zz")
		}//数组可以存放**对象地址**，数组空间确定的同时，数组指向**地址的对象**也初始化了
```
		- 动态初始化：数组空间，数组指向对象的空间；单独一一确定
```java
		int[] c=new int[3]//默认初始化，同成员函数一样，默认为0/null/false
		int[] a=new int[2];
		a[0]=1;
		a[1]=2;//动态初始化，数组空间，数组指向对象的空间；单独一一确定
```
	- 数组遍历foreach
		- 专门用于读取数组元素额值，而不是赋值
```java
		for(Person outPerson:arr2){
		system.out.println(Pesson.getId());	
		}//“：” ；同时可以用对象.getId()
```
		
	- 异常：ArrayIndexOutOfBoundsException数组越界，比如数组只有10个，你写到了arr[10]


- 方法区
	- static
		- 变量：从属于类（非static的变量从属于函数/对象）
		- 静态初始化块
			- JVM运行时会提前调用
			- 顺序：父类静态代码块->子类静态代码块
- 参数传值机制
	- 一般是值传递，例如：传的是int
	- 如果传递的是对象，则传递的为：对象地址的复制
	- 值传递底层操作
		- 在类的方法中，创造一个和参数一样的对象
		- 将参数的地址赋予这个对象--即类似于分身
		- 特殊例子：若是方法的代码写成：className=new newClass();这样子则说明，赋值的对象地址更换为【另一个新的对象的地址】，则那么与原先的参数就没有关系了

### 包 package（在不在同一个大千世界下）
- 简介：类似于文件夹，对类的管理
- 在src(源码)中创建
	- 结构--分为5层
		- 项目
		- 项目：lib(编译器给你创建的) + src(source)(自己创建的源代码)
		- 源代码： ♥ 包（域名倒写+自己包名）
		- 包：".java文件"
		- ".java文件"：public class+其他class
	- 域名倒着写：
		- 域名：独一无二，不会重复
		- 倒着写：习惯
		- com.github.floatLig.oo/newbie
		- 常见域名解释：org(非营利组织)  com(公司)
- 默认包：是不会创建文件夹的，因此，写项目的时候要加上自己的包
- java提供的很多包都是以java开头的
- 导入包：
	- **导入**什么**包**中的什么类/\* --**连通大千世界**
	- 导入别人写的包
	- 静态导入：import static java.lang.Math.PI
	- java.lang：（language）lang包是默认导入的，所以不用写也可以

-----

## 继承、封装、多态

### 继承 extends
- 蓝图更加具体化
	- 父类：又称为超类、基类、派生类（从之中派生）
	- 在内存模型中，对象要想到有父类的蓝图（包括超级父类object类）
	- object是所有类的父类
	- 查看继承结构树：
		- Ctrl+T（tree）
		- 右键--open type hirrarchy
- 接口可以多继承
- 原理：
	- 子类继承父类--可以**得到**类的全部属性和方法（除了构造方法）
	- 可是**不见得可以直接访问**，比如：私有成员和方法
- 重写
	- 重写返回值类型 可以重写并返回子类的的类型
		- 可以说是具体化了吧
	- 返回值类型和声明异常类型，子类等于父类
	- 重写的访问权限要【大于等于】父类，原因是：向上转型；可以调用父类，子类也必须可以调用，不然就没用了
- object类（超级父类）
	- tostring是最常用的方法
		- 打印：具体路径（包+类名）+哈希地址值
	- ==
		- 用于判断值时候相等：1==1
		- 引用类型：地址==地址，是不是同一个对象
	- equal
		- 用于判断对象是否相等，经常重写，不重写默认为（==）
		- 右键--source--equal（哈希的重写可以删掉）；其他小操作：右键--source--可以生成构造器generate construction form fields
		- String也重写了equal的方法
- super()直接父类的引用
	- 可以通过super来访问父类中被子类覆盖的方法或属性
	- 构造方法的第一句是默认super（）
		- 因此，在构造子类之前，必须先执行super（），即先创建父类的对象，包括**属性和方法**；接着在创建子类，同名的属性或方法则会被子类覆盖

### 封装
- 高内聚、低耦合；便于外部使用
- 就是加访问控制符
	- default：本包可以使用，同一个大千世界下
	- protected：不同包，只有使用extends的子类可以用（保护）
	- public：导入包中的这个类就可以
	- private：子类也看不到，只有类本身可以看的到（别人拥有一切，但是不能访问）
	- 一般的普通程序
		- 类的属性：private
		- 方法：public
		- setAge()赋值：在这个方法中，如果符合则成功赋值，如果不符合，则不给予赋值
		- getAge()获得值
		- isMan()布尔值
		- set/get右键--source生成
	
### 多态（一个方法的调用，由于对象不用而有着不同的行为）
- 多态是方法的多态，不是属性的多态
- 条件（必须都有）
	- 继承
	- 方法重写
	- 父类引用子类对象
	- 一个方法的参数是父类对象，子类作为参数被调用，多态就出现了（类似于c++的虚函数）
- 理解：同一个方法，不同的对象有不同的做法（前提是他们父类一样，是同一种类别）
- 转型casting
	- 向上转型：身份是父类

-----

## 思考经验
- 自己打代码：（对象化）
	- 初始值只会赋值一次
	- 半括号的范围：友半括号-向上
	- 终端光标要手动转到下一行
- 有疑问的，记住，然后后面学到的，可以解决前面的知识
- 学习JDK的源码是我们学习编程的一个非常好的套路
- [eclipse结构树的图标含义](https://blog.csdn.net/androidolblog/article/details/45503515)
- AWT和swing基本用不到，用到什么学什么，用不到就拉倒
