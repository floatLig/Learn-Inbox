# Java
### Java初级
- [成员变量](#成员变量)
- [函数](#函数)
- [面向对象](#面向对象)
- [思考经验](#思考经验)

## 成员变量 

###  注释
- 单行注释
- 多行注释：
- 文档注释：文档注释会**自动生成API**，因此开发项目最好使用文档注释
```java
	//单行注释
	
	/*
	 * 多行注释
	 */
	
	/* 多行注释的另一种用法，可用于代码中间解释，但不推荐*/
	
	/**
	 * 文档注释
	 * 文档注释：比多行注释多写了一个*
	 */
```
		
### public static final *double* MAX_MARK =(1.0+90L)之double
- 基本数据类型
	- boolean是1byte
	- char可以用作数字处理：'a'+4=101
	- 使用long时：123L而不是123l(很容易混淆)
	- 不要long a=b+c而要long a=(long)b+c
		- （long）b会自动将右边的等级提成为long，这样就不要报错
	 
### public static final double *MAX_MARK* =(1.0+90L)之MAX_MARK
- 标识符命名规范
	- 驼峰原则：studentAge
	- class类名：首字母大写
	- 成员变量、函数：首字母小写
	- final常量：全部大写，用下划线连接
- 变量
	- 一行申明一种变量就可以，不要多写

```java
	int age;  
	int grade;
```

	- 静态变量static
		- 从属于**类**
	- 成员变量
		- 会有默认初始值，故可以不用初始化
		- 从属于**对象**
	- 局部变量
		- 从属于**方法**
	- 这些变量在初始化时，**最好都赋初始值**

### public static final double MAX_MARK *=* (1.0+90L)之=
- 自动类型转化
	- 容量小的数据类型向容量大的数据类型转化:int->long->float->double
	- 1e2=100
	- 整数默认是int类型，小数默认是double类型
	- 强制类型转化
```java
	long a=1;//这里的1是int,int自动转化为long
	float b=1.0F;//这里的1.0是double，double不能自动转化为float，所以必须写成1.0F
```
	- 因为浮点数（float、double）是自动类型转化，因此不精确。若是要精确的比较使用**BigDecimal函数**

### public static final double MAX_MARK = (1.0*+*90L)之+
- 运算符
	- %取余
```java
		int a=-7%-2;//-7影响结果为“-”;-2对结果的正负不影响
		System.out.println(a);//-1：
```
	- 运算符会自动转化类型
- 逻辑运算符
	- &&短路与--&与
```java
		boolean a= (1>2)&&(1/0>1);//不会报错“除数为0”，因为遇到前面是false，短路与&&不会继续往后看，写代码时推荐使用这个
		boolean b= (1>2)&(1/0>1);//会报错，因&无论前面是true还是false,都会继续往后读
```
- 位运算符
	- & | ^ ~
	- <<2:左移两位即“乘2”
	- +字符串连接符：1+“2”=12
	
### 对象
- Scanner
	- Scanner sc=new Scanner(System.in)

-----

## 函数
- 流程控制语句
	- 顺序
	- 选择(i)
		- if else
		- switch(case不用加{})
	- 循环
		- for
		- while
		- break、continue终止的是循环，而不是if【若要跳出多层循环，使用return跳出函数】
		- continue,break配合if在循环中使用
	- 任何算法都是建立在顺序、选择、循环之上的
	- 多个for，最外层的for是最大框架
- public static void main(String[] args)
	- return
		- 返回类型
		- 终止函数
- 常用
	- 函数被static修饰（属于类），可直接调用，不用创建该类的对象（public不行，因为public的功能不是这个）

-----

## 面向对象

### 生活皆对象
- 编程思想（逐渐进步）
	- 面向过程思想
		- 一步一步怎么做
		- 适合简单，不需要协作的事务
	- 数组
		- 数据也是对象
	- 面向对象
		- 宏观上用面向对象把握，微观仍是面向过程->函数
		- 都是解决问题的思维方式，都是代码组织的方式
		- 量变引起质变
- 生活中的对象
	- 公式项目制
		- 微信项目组--包括财务，可以说是独立公司
		- 麻雀虽小五脏俱全

### 编程中的对象实现
- 类（蓝图）（抽象-抽出像的东西）
	- 属性（调用对象的属性“.”）
	- 成员方法（调用对象的方法“.”）
	- **类中有类**
	- 书写注意：类是没有参数的
- 对象object / instance（实例）
	- 和对象的关系
		- 是对象的模板
	- 使用：用new调用构造方法->初始化/实例化
		- 无参的构造方法由系统自动创建
		- 方法名称和类名保持一致
		- 经常重载（不用实例化）
		- this:表示创建的**这个对象**
		- 构造方法的第一句都是super（）--系统默认添加
	- 底层操作
		- 在堆中分配对象空间，并将对象成员初始化为0或null
		- 执行属性值的显式初始化（实例化）
		- 执行构造函数（实例化）
		- 返回对象地址给相关的变量
	- this
		- 表示创建的这个对象
		- 不能用于static，因为static位于方法区，而this只能调用**堆**里面对象的东西

### JVM的内存分析
![](https://github.com/floatLig/Learn-Inbox/blob/master/media/%E5%A0%86%E3%80%81%E6%A0%88%E3%80%81%E6%96%B9%E6%B3%95%E5%8C%BA.png)
- 栈stack--**DO**
	- 描述的是**方法**执行的内存模型
		- 主函数main运行
		- 构造函数（运行后立马被销毁）
	- 类似于子弹夹
		- 栈帧
		- 线程私有：不能共享
		- 先进后出，后进先出：main是最先创建的，最后销毁
		- 速度快
- 堆heap--**实例-大千世界**
	- 存放创建好的对象和数组（数组也是对象）
	- 所有线程共享
	- 不连续的内存空间，分配灵活、速度慢
- 方法区method area--**蓝图、基础数据**
	- JVM只有一个方法区，被所有线程共享
	- 方法区实际上也是堆，用于储存**类，常量的相关信息**--静态的一些数据
		- 代码
		- 静态变量
		- 静态方法
		- 字符串常量
- 合起来
	- **栈**（ToDo）调用堆的对象，堆的对象的内容由其他堆、方法区的内容组成

###垃圾回收机制Garbage Collection
![](https://github.com/floatLig/Learn-Inbox/blob/master/media/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6.png)
- 针对对象（**堆**），类似回收垃圾的服务员
	- C++没有垃圾回收机制，使用后必须把残渣带走，如果没有带走，则这块内存不能使用
- 算法：根搜索算法（引用可达法）
- 原理
	- 发现无用的对象
	- 回收无用对象占用的空间
	- Minor GC/Major GC/Full GC(全部清理，代价较高)
	- 年轻代
		- Eden：对象刚创建出来
		- Survival1
		- survival2
	- 年老代
		- Tenured/Old
	- System.gc()
		- 向系统建议调用垃圾回收机制
		
-----

## 思考经验
- 自己打代码：要模型化（对象化）
	- 初始值只会赋值一次
	- 半括号的范围：友半括号-向上
	- 终端光标要手动转到下一行
- 对象化
