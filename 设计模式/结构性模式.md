## 结构型模式

**核心简介：**
1. 结构型模式是为了解决“怎么组装现有的类”，设计他们的“交互模式”，从而达到一定功能的目的
2. 结构性模式包容了对很多问题的解决。
	1. 扩展性：外观、组成、代理、装饰
	2. 封装性：适配器、桥接

### 代理模式

**核心作用：**
1. 通过代理，控制对对象的访问（经纪人：和核心业务无关的）
2. 可以详细控制访问某个（某类）对象的方法，在调用这个方法前可以做前置处理，也可以这个方法后做后置处理
3. AOP（Aspect Oriented Programming面向切面编程）的核心实现机制

**应用场景：**
1. 安全代理：屏蔽对真实角色的直接访问
2. 远程代理：通过代理类处理远程方法调用（RMI）
3. 延迟加载：先加载轻量级的代理对象，真正需要再加载真实对象
4. struts2中拦截器的实现
5. 数据库连接池关闭处理
6. Hibernate中延时加载的实现
7. mybatis中实现拦截器插件
8. spring中AOP的实现
	1. 日志拦截
	2. 声明式事务处理
9. web serbice
10. RMI远程方法调用

**分类：**
1. 静态代理：我们自己定义代理类 
2. 动态代理：自动/动态生成代理类（√）
	1. ！代理的生成不用你管，由系统动态生成
	1. JDK自带的的动态代理
	2. javaassist字节码操作库实现
	3. CGLIB
	4. ASM

### 组合模式Composite

**场景：**
1. 把部分和整体的关系用树形结构来表示，从而使客户端可以使用统一的方式处理部分对象和整体对象

**核心**
1. 抽象构件Component角色：定义了叶子和容器构件的共同点
2. 叶子Leaf构件角色：无子结点
3. 容器Composite构件角色：有容器特征，可以包含子结点

**开发场景：**
1.　Junit单元测试框架
2.　OA系统中，组织结构的处理
3.　XML文件解析
4.　GUI中容器层次图
5.　操作系统的资源管理器

### 装饰器模式

**职责：**
1. 动态的为一个对象增加一个新的功能
2. 装饰模式是一种用于代替继承的技术，无须通过继承增加子类就能扩展对象的新功能 

修饰类的参数（可以穿装饰类的对象），就可以实现多个功能

**开发场景：**
1. IO输入流和输出流的设计
2. Servlet API中提供的一个request对象的Decorator设计模式的默认实现类HttpServletRequestWrapper,HttpServletRequestWrapper类，增强了request对象的功能（看到Wrapper就是装饰器）
3. Struts2中，request，response，session对象的处理

**装饰模式和桥接模式的区别：**
两个模式都是为了解决过多子类对象问题。但是他们看待问题的角度不一样。桥接模式是现有机制沿着多个维度变化，而装饰模式是为了增加新的功能

### 外观模式

迪米特法则（最少知识原则）
一个软件实体应当尽可能少的与其他实体发生相互作用

最常见

### 享元模式FlyingWeight

**场景：**
1. 内存属于稀缺资源，不要随便浪费，如果有很多个完全相同或相似对象，我们可以通过享元模式，节省内存

**核心：**
1. 享元模式以共享的方式高效的支持大量细粒度对象的重用
2. 享元对象能做到共享的关键是区分了内部状态和外部状态
	1. 内部状态：可以共享，不会随环境变化而改变
	2. 外部状态：不可以共享，会随环境变化而变化

**开发场景：**
1. 享元模式由于共享的特点，可以在任何“池”中操作，比如：线程池、数据库连接池
2. String类的设计也是享元模式

**优点：**
1. 减少内存对象数量

**缺点：**
1. 模式复杂，使程序复杂
2. 共享了内部状态，分离出了外部状态，从而读取外部状态使运行时间变长。时间换取空间

只有出现池，就是容器

## 行为型模式

### 责任链

**定义：**
将能够处理同一类请求的对象连成一条链

代替if..else()语句

**应用场景**
1. 异常机制try catch
2. servlet开发中，过滤器的链式处理
3. Struts2，拦截器也是责任链

### 迭代器模式iterator

**场景：**
1. 提供一种可以遍历聚合对象的方式
2. 聚合对象：存储数据
3. 迭代器：遍历数据

**开发场景**
1. JDK内置的迭代器（List/Set）

### 中介者模式

**核心：**
1. 系统间对象之间的联系呈现为网状结构，存在多对对结构，引入中介模式，将复杂的结构化解为星型模式

**开发场景**
1. MVC模式，，其中的C，控制器就是一个中介者对象
2. 反射的invoke（）方法

#### 命令模式


### 解释器模式
1. 开发一种新的语言
2. 尽量不用使用解析器模式，后期维护会有很大的麻烦
3. 可以使用Jruby，Groovy，js引擎代替解释器的作用，弥补Java语言的不足

**开发中常见的场景：**
1. EL表达式的处理
2. 正则表达式解释器
3. SQL语法解析器
4. 数学表达式解析器

### 访问者模式

**开发场景（应用范围非常窄，了解即可）**
1. XML文档解析器的设计
2. 编译器的设计
3. 复杂集合对象的处理

### 策略模式

核心：
策略模式对应于解决某一个问题的一个算法族，允许用户从该算法族中任选一个算法解决某一个问题

**开放场景：**
1. Spring框架中，Resource接口，资源访问策略

### 模板方法模式

定义了一个算法骨架，

核心：
 处理步骤父类中定义好，具体实现延迟到子类中定义

**方法回调（钩子方法）**
1. 好莱坞原则：Don't call me, we'll call you back.
	1. 即：子类不能调用父类，而通过父类调用子类。这些调用步骤已经在父类中写好了，完全由父类控制整个过程

**什么时候用到模板方法模式：**
1. 实现一个算法时，整体步骤很固定，但是，某些部分易变。易变部分可以抽象出来，供子类重写实现
2. 数据库访问的封装
3. Junit单元测试
4. servlet中关于doGet/doPost方法调用
5. Hibernate模板程序
6. spring中JDBCTemplate、HibernateTemplate

### 状态模式

**核心：**
用于解决系统中复杂对象的状态转换以及不同状态下行为的封装问题

**开发场景：**
1. 银行系统中账号状态的管理
2. OA系统中公文状态的管理
3. 酒店系统中，房间状态下的管理
4. 线程对象各状态的切换

### 观察者模式

是实现广播机制的核心

把多个订阅者、客户称为观察者；需要同步给多个订阅者的数据封装到对象中，称之为目标 

**核心：**
1. 观察者模式主要用于1：N的通知
2. 推：每次通知都会以广播方式发送给所有观察者，观察者被动接受

**开发场景：**
1. 聊天室程序中，服务器转发给所有客户端
2. 网络游戏
3. 邮件订阅
4. Servlet，监听器的实现
5. Android中，广播机制
6. JDK中AWT中事件处理模型

### 备忘录模式

**场景：**
1. PS的历史记录
2. Ctrl + Z

**核心：**
1. 保存某个对象内部状态的拷贝，这样就可以恢复到原先的状态

**开放场景：**
1. 棋类游戏中的，悔棋
2. 数据库软件中，事务管理的回滚操作

###简单工厂模式

1. 在实际开发中，还可以在调用时将所传入的参数保存在XML等格式的配置文件中，修改参数时无须修改任何源代码


设计模式的6条原则：
1. 单一职责原则
2. 里氏替换原则
3. 依赖倒置原则
4. 接口隔离原则
5. 迪米特法则
6. 发放封闭原则
https://www.jianshu.com/p/807bc228dbc2