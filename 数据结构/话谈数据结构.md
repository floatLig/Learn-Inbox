## 目录
- [栈](栈)
- [队列](队列)

## 栈

**定义：**
1. 栈是一种使用受限的线性表，它只能在栈顶进行操作--入栈和出栈；
2. 后进先出是它最大的特点；
3. 栈既可以用数据来实现，也可以用链表来实现；
4. 无论入栈还是出栈，时间复杂度都是O（1）；

**栈为什么而诞生：**


**栈适用的场景：**
计算机的算数运算：3+5*8-6
```
需要定义两个栈：符号栈X和数字栈Y
从左向右扫面字符串，遇到数字栈就将数字压入数字栈Y中；
遇到符号就：将符号同符号栈X的栈顶元素进行比较，如果优先级高则压入栈顶，如果优先级低则“取数字栈Y的两个操作数和符号栈X的一个符号进行运算操作，然后将结果压入数字栈中”
```
编程中的函数调用
```

```
()[]{}括号匹配
```
从左向右扫面字符串，如果遇到（[{就将其压入栈中，如果遇到)]},就将栈顶的元素进行比较，如果配对的弹出栈顶元素；
当所有的字符串扫描完毕后，并且栈中没有元素存在（所有的元素都被弹出去了）就说明括号匹配成功。
```
浏览器的前进后退功能
```
情景：用户在浏览器打开页面，可以实现浏览页面的前进和后退功能；当用户新建了页面，则之前的“可以前进的页面”都会被清零。

需要定义两个栈，假设为X，Y
X栈：存储打开的页面，假设为a,b,c
Y栈：如果用户后退，就将最上面的元素存到Y栈中；如果用户前进，就将Y栈中最上面的元素弹出并存到X栈中；如果用户新建页面，着Y栈中的所有元素清零。

```

**栈的优点：**

**栈的局限性：**

**如何使用栈：**
- **入栈**
	空间复杂度：需要额外使用几个临时变量，因此空间复杂度为O（1）；需要注意的是，顺序栈需要一个大小为n的数组，但是因为这个大小为n的数组是必须存在的，因此不算入空间复杂度中。
- **出栈**

**额外拓展--支持动态扩容的顺序栈**
	
--》实际应用中并不常见，主要懂得如何分析时间复杂度。
情景：当栈的存储空间不够时，会重新申请一块大小为原来2倍的内存大小，并将所有的数据搬移过去。
时间复杂度分析：假设原来的空间大小为k,当这个空间满了之后，会重新申请2k的空间大小，然后将k的数据搬移过去，再进行入栈操作；因此在接下来的操作中，k-1的入栈操作时间复杂度为O（1）【最好时间复杂度】，1次的入栈操作是O（K）【最坏时间复杂度】；采用均摊时间复杂度分析方法，一次的O（K）入栈操作的时间均摊到每一次的O（1）入栈操作，那个每次的入栈操作的时间复杂度就变成O（1）+1；因此总的时间复杂度还是O（1）；由此可见，像这种情况，如果采用均摊时间复杂度，那么均摊下来的时间复杂度等于最优时间复杂度O（1）。

## 队列

**定义：**
1. 特点是：先进先出，通过设置head、tail两个信号量来控制进队和出队
2. 是一种受限制的线性表，队列的延申还有循环队列、阻塞队列、并发队列；
3. 可以用数组和队列来实现，但是数组的引用更加广泛？
4. 循环队列中入队和出队的时间复杂度都为O（1)

**队列为什么而诞生:**

**队列的使用:**

入队：enqueue()

出队：dequeue()

循环队列
```
利用模运算：提高空间的利用率，解决数据搬移问题；
循环队列中：head指向的空间有数据；tail指向的空间没有数据；
原因为：队列为空的时候head=tail，插入数据时，head指向的空间插入数据，tail后移，仍没有数据

判断队列是否为空：head==tail
判断队列是否满了：(tail+1)%n==head【%就是取模的意思】[这里注意是tail+1而不是head+1]
入队:tail=（tail+1）%n
出队：head=(head+1)%n
```
阻塞队列
```
阻塞队列在队列的基础上增加了阻塞操作。即队列为空的时候，取数据会被阻塞；队列满的时候，插入数据会受到阻塞

可以通过empty，full等信号量来实现

阻塞队列实际上就是“生产者消费者模型”
```



**队列的应用场景:**

线程池
```
当队列满的时候，有两种处理方式：
1. 非阻塞方式：直接拒绝
2. 阻塞方式：等待其他的数据被取出
```
在任何有限的资源中，用于排队请求：数据库连接池
**队列的优点:**

**队列的缺点:**


